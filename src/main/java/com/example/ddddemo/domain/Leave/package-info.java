package com.example.ddddemo.domain.Leave;

/**
 * 聚合层
 *  聚合就是由业务和逻辑紧密关联的实体和值对象组合而成的，聚合是数据修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化。
 *
 * 聚合根
 *  如果把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也称为根实体，它不仅是实体，还是聚合的管理者。
 *  辅助理解：核心聚合
 *  例子： 客户 地址 账户 ，客户就是核心聚合。 由客户 来协调地址、账户的逻辑，保持数据一致。
 *
 * 设计原则：
 *  1. 在一致性边界内建模真正的不变条件。
 *      聚合用来封装真正的不变性，而不是简单地将对象组合在一起。聚合内有一套不变的业务规则，各实体和值对象按照统一的业务规则运行，
 *      实现对象数据的一致性，边界之外的任何东西都与该聚合无关，这就是聚合能实现业务高内聚的原因。
 *  2. 设计小聚合。
 *      如果聚合设计得过大，聚合会因为包含过多的实体，导致实体之间的管理过于复杂，高频操作时会出现并发冲突或者数据库锁，
 *      最终导致系统可用性变差。而小聚合设计则可以降低由于业务过大导致聚合重构的可能性，让领域模型更能适应业务的变化。
 *  3. 通过唯一标识引用其它聚合。
 *      聚合之间是通过关联外部聚合根 ID 的方式引用，而不是直接对象引用的方式。外部聚合的对象放在聚合边界内管理，
 *      容易导致聚合的边界不清晰，也会增加聚合之间的耦合度。
 *  4. 在边界之外使用最终一致性。
 *      聚合内数据强一致性，而聚合之间数据最终一致性。
 *      {@在一次事务中，最多只能更改一个聚合的状态。}
 *      如果一次业务操作涉及多个聚合状态的更改，应采用{@领域事件}的方式异步修改相关的聚合，实现聚合之间的解耦。
 *  5. 通过应用层实现跨聚合的服务调用。
 *      为实现微服务内聚合之间的解耦，以及未来以聚合为单位的微服务组合和拆分，应避免跨聚合的领域服务调用和跨聚合的数据库表关联。
 *
 * 聚合的特点：
 *  高内聚、低耦合，它是领域模型中最底层的边界，可以作为拆分微服务的最小单位，但我不建议你对微服务过度拆分。
 *  但在对性能有极致要求的场景中，聚合可以独立作为一个微服务，以满足版本的高频发布和极致的弹性伸缩能力。
 *  一个微服务可以包含多个聚合，聚合之间的边界是微服务内天然的逻辑边界。
 *  有了这个逻辑边界，在微服务架构演进时就可以以聚合为单位进行拆分和组合了，微服务的架构演进也就不再是一件难事了。
 *
 * 聚合根的特点：
 *  聚合根是实体，有实体的特点，具有全局唯一标识，有独立的生命周期。
 *  一个聚合只有一个聚合根，聚合根在聚合内对实体和值对象采用直接对象引用的方式进行组织和协调，聚合根与聚合根之间通过 ID 关联的方式实现聚合之间的协同。
 *  {@解释 对应设计原则5，应用层 从聚合根A中 拿到聚合根B的id，由应用层，调用聚合根B 完成B的内部逻辑。}
 *
 * 实体的特点：
 *  有 ID 标识，通过 ID 判断相等性，ID 在聚合内唯一即可。状态可变，它依附于聚合根，其生命周期由聚合根管理。实体一般会持久化，但与数据库持久化对象不一定是一对一的关系。实体可以引用聚合内的聚合根、实体和值对象。
 *
 * 值对象的特点：
 *  无 ID，不可变，无生命周期，用完即扔。值对象之间通过属性值判断相等性。它的核心本质是值，是一组概念完整的属性组成的集合，用于描述实体的状态和特征。值对象尽量只引用值对象。
 *  例子 用户地址信息，如果仅仅是用户的附属品用于展示、传输等，没有自己的内部逻辑，用一个json保存其内部结构 并作为varchar存储，就是值对象。（可以简化设计，减少不必要的投入，也能侧面去突出核心）
 */